
TODO NEXT:
- refactor jumi-actors
	OK - rename package to fi.jumi.actors.maven
	OK - rename factories to Eventizer (also generated)
	OK? - make it impossible to use actors wrong
		OK - ActorRef (might make spawners and auto wrapping unnecessary!)
			OK - return ActorRef from creation methods instead of the proxy
			OK - in all constructors and fields, use ActorRef instead of proxy to make it easier to keep track of the communication patterns
			OK - use ActorRef in callbacks (WorkerCounter, unattended workers, other method parameters if any)
		SKIP - wrap all NonThreadSafe collaborators of a worker automatically into a secondary actor.
			Usage:
			        Spawner<DriverRunnerFactory> driverRunnerSpawner = new Spawner<DriverRunnerFactory>(DriverRunnerFactory.class, new BareDriverRunnerFactory());
			        // ...
			        driverRunnerSpawner
			                .whenFinished(new OnWorkerFinished())
			                .create(testClass, driverClass, listener /*NOT thread-safe*/, executor /*thread-safe*/);
			Boilerplate:
				interface DriverRunnerFactory {
				    DriverRunner create(Class<?> testClass, Class<? extends Driver> driverClass, TestClassListener listener, Executor executor);
				}
				class BareDriverRunnerFactory implements DriverRunnerFactory {
				    @Override
				    public DriverRunner create(Class<?> testClass, Class<? extends Driver> driverClass, TestClassListener listener, Executor executor) {
				        return new DriverRunner(testClass, driverClass, new DefaultSuiteNotifier(listener), executor);
				    }
				}
		SKIP - use OnDemandActors only in classes whose responsibility is to start actors; current users:
			- fi.jumi.core.runners.DriverRunnerSpawner
				- now too complex
			- fi.jumi.core.runners.TestRunSpawner
				- now too complex
			- fi.jumi.core.runners.SuiteRunner & fi.jumi.core.TestRunCoordinator
				- extract TestClassFinderSpawner
			- fi.jumi.core.runners.TestClassRunner
				- push dependencies out of constructor (pass WorkerCounter and `this` as method parameters to DriverRunnerSpawner)
	OK - create a class (Actor?) to represent Actors.queueOfCurrentActor
		OK - wrap the MessageQueue in it
		OK - move processing the next message in it
		OK - move wiring the MessageQueue in it
			OK - from createPrimaryActor
			SKIP - from createSecondaryActor
	OK - make all events of type CustomTargetEvent (or would it complicate custom prosessing the messages? do we need to use MessageQueue<MessageToActor> for direct messages, and MessageQueue<Event<T>> for networking and stuff?)
		OK - make primary actors use CustomTargetEvent
		OK - remove duplication: unify the message processing/sending of primary and secondary actors
			OK - unify SingleThreadedActors.EventPoller and Actors.ActorContext
			OK - maybe doable by setting up the context for every message also in MultiThreadedActors, or get rid of the need for more than one context in SingleThreadedActors
	OK - separate creating ActorRefs from assigning threads. Might allow creating ActorRefs/secondary actors in constuctors, outside actor thread.
		OK - estimate whether it would make code simpler and/or help to get rid of spawners
		OK - create interface ActorThread.createActor(Object): ActorRef
		OK - create Actors.newThread(): ActorThread
		OK - refactor the code to use it (at first probably only Main creates the thread)
		OK - rename/remove fi.jumi.actors.LongLivedActors
	SKIP - create Actors.getCurrentActor: ActorRef (or maybe it's not needed when creating refs and threads are separated?)
		- implement using the thread-local actor context
		- use it instead of createSecondaryActor(this)
	OK - either, decouple unattended workers from Actors
		OK - hide WorkerCounter, create a wrapper: new MonitoredExecutor(realExecutor, onAllFinishedCallback)
			OK - thred safe, counts commands with AtomicInteger
			SKIP - executes the callback using realExecutor, as its own command
		SKIP - create a MonitoredExecutorSpawner which executes the callback in the current actor thread
		OK - make it work for commands which launch other commands (when backed by an asynchronous executor)
		OK - test: a single command
		OK - use BlockingQueue in tests instead of latches where possible
			OK - extract fi.jumi.actors.ActorsContractHelpers#events to EventSpy
		OK - use MonitoredExecutor instead of Actors.startUnattendedWorker (keep SingleThreadedActors.getExecutor)
		OK - remove Actors.startUnattendedWorker
		OK - try removing fi.jumi.core.runners.TestClassRunnerListener#onTestClassFinished
		OK - try removing fi.jumi.core.runners.WorkerCounter, replace with the new MonitoredExecutor
		OK - rename/remove fi.jumi.actors.OnDemandActors
	SKIP - or, implement unattended workers as actors which stop themselves (Thread.interrupt()) after running the command
	OK - eliminate spawners
	OK - refactor actor tests
		OK - some tests might be outdated; update or remove them
		OK - rename any remaining "factories" variables and methods to "eventizers"
	OK - make DynamicListenerFactory support all types without having to declare them
		OK - move the type comparison in Actors.getFactoryForType to ListenerFactory.supportsType
		SKIP - need to give type as parameter to DynamicListenerFactory.newFrontend/newBackend?
		OK - refactor tests to use just one DynamicListenerFactory, use generated factories only in Main
		OK - make Actors(EventizerLocator) the only constructor, to make the design clearer, reduce code and avoid mistaking DynamicEventizer for DynamicEventizerLocator
		OK - rename EventizerLocator to EventizerProvider?
		OK - ComposedEventizerLocator: move the last test from ActorsContract to ComposedEventizerLocatorTest
		OK - ComposedEventizerLocator: use a HashMap
		OK - DynamicEventizer: check that the parameter is an interface (write tests)
		OK - DynamicEventizerLocator: cache the eventizers to avoid re-checking the same types, or premature?
			OK - write a benchmark first: http://code.google.com/p/caliper/
				- micro-benchmark creating a single actor
				- create lots of short-lived actors and send to each of them only one message
	SKIP - consider creating NakedActorRef for unit testing, ProxyActorRef for production
		- throw an exception in fi.jumi.actors.ActorRef#wrap if not a proxy (see TODO), or is it even possible because of not always using dynamic proxies?
	OK - remove support for named actor threads
		OK - remove name parameter from startActorThread
		OK - MultiThreadedActors: don't create threads manually
			OK - use thread pool
			OK - remove the constructor which creates a default thread pool; the caller shall manage its lifecycle
			OK - remove shutdown method (use ExecutorService.shutdownNow/awaitTermination directly in tests)
		OK - create PrefixedThreadFactory, e.g. "foo-" -> "foo-1", "foo-2" etc.
		OK - use it in Main, prefixes: "jumi-actors-", "jumi-tests-"
	OK - pluggable logger
		OK - create interface MessageLogger, class NullMessageLogger
		OK - replace logging in MessageQueue with it
		OK - create class SimpleMessageLogger to core tests, use in SuiteRunnerIntegrationHelper
		OK - write a test for the information shown in Actors.MessageToActor.toString()
		OK - make sure that toString of reflective and generated messages are the same
		OK - add logging to Executors, to see which actor started which worker thread?
	OK - improve log readability
		OK - toString for fi.jumi.actors.workers.WorkerCountingExecutor.Worker
	OK - SingleThreadedActors.getExecutor() should use MessageLogger
	OK - support for stopping actors
		OK - interrupting stops after current message
		OK - ActorThread.stop() stops after processing all previous messages
		SKIP - create ActorThread.isAlive(), or is it unnecessary? or useful for testing?
		OK - consider removing fi.jumi.actors.Actors#currentActorThread because now resources can be released
		OK - SingleThreadedActors: unifying actors and the Executor
			- implement commands as actors which are stopped immediately after executing them?
			- have only one actor thread? might not be possible when supporting stopping?
		OK - stopping actor threads: handle java.lang.InterruptedException
		OK - use Thread.currentThread().interrupt() in fi.jumi.actors.mq.MessageQueue#send
			OK - test: keeps interrupt status of the current thread
			OK - test: enqueues even when interrupted
			OK - consider using the add() method
	OK - handle exceptions from actors (in general, not just in single-threaded actors)
		OK - move exception handling from SingleThreadedActors#processEventsUntilIdle into ActorThreadImpl#process
		OK - move exception handling from MultiThreadedActors.BlockingActorProcessor#run into ActorThreadImpl#process
		OK - remove fi.jumi.actors.SingleThreadedActors#handleUncaughtException
		OK - create fail-early version of failure handler, use it in fi.jumi.core.runners.SuiteRunnerIntegrationHelper
		OK - use UncaughtExceptionCollector in ActorsContract
		OK - dynamic events won't rethrow InterruptedException and thus stop the actor; remove support for the feature?
		OK - test: actor should stay alive, process following messages (unless handler throws exception?)
		OK - test: how to stop actors which throw exceptions
		OK - pass also the message to uncaughtException()
	OK - misc refactoring
		OK - ActorThreadImpl: change execute(Runnable) to send(MessageToActor), then could get rid of asserts in process()
		OK - rename DeathPill to PoisonPill; more common word, also used in Akka
		OK - rename fi.jumi.actors.logging.MessageLogger to MessageListener? also getLoggedExecutor to getListenedExecutor, and use full name in Actors field
		SKIP - rename fi.jumi.actors.failures.FailureHandler to UncaughtExceptionHandler?
		OK - rename packages: logging & failures -> listeners, mq -> queue?
	OK - SilentFailureHandler is not used, create PrintStreamFailureHandler?
	OK - rename:
		OK - SilentMessageLogger -> NullMessageListener
		OK - PrintStreamFailureHandler -> PrintStreamLoggingFailureHandler / PrintStreamFailureLogger
		OK - PrintStreamMessageLogger -> PrintStreamLoggingMessageListener / PrintStreamMessageLogger
	OK - DynamicEventizer should not forward calls to equals/hashCode/toString (i.e. any methods not declared on the interface)
	OK - actor interface contracts
		OK - create ActorInterfacesTest, move related tests from DynamicEventizerTest
		OK - extract eventizer contract checks from DynamicEventizer to Eventizers.validateActorInterface(Class)
		OK - make it explicit that events cannot throw exceptions
		OK - use also from the maven plugin
		OK - show the class name in all failure messages
	!! - logging WorkerCounter's onFinished events could benefit from using a custom interface; now "Runnable.run()" shows up in logs and requires interpreting
		- create WorkerListener.onAllWorkersFinished() and migrate away from Runnable
	- publish a build (only jumi-actors, jumi-actors-maven-plugin, parent?)
		OK - See below: include Git revision in pom.properties
		- push the button, check the OSSRH repo, release
		- active sync to Maven Central
	- write user documentation for jumi-actors
		- example: hello world (put on front page)
		- example: pi (put in wiki), adapted from http://doc.akka.io/docs/akka/2.0.2/intro/getting-started-first-java.html
		- www: maven dependency xml, latest version number, link to http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22fi.jumi%22

- end-to-end tests: running multiple test classes
	- it's not sure whether SuiteRunner works correctly when there are many test classes
	- test class inclusion patterns (*Test, Test*, some.package.*, some.package.** etc.)

- end-to-end tests: reporting test output
	- capture System.out/err
	- send out/err events
	- test: printing from the same thread to out & err should be synchronous, unlike in probably every IDE
	- hacking System.out/err
		- tests should restore the original out/err defensively in @After
		- concurrency test: out.println("O") and err.println("E") from different threads, output must not contain "OE"/"EO" but only "O\nE\n"
		- unit test: the PrintStreams for our & err must sync on the same object, testable by checking holdsLock in a mock OutputStream
			- Thread.holdsLock(java.lang.Object)
			- ReentrantLock.isHeldByCurrentThread()
		- generic test: all methods on our custom PrintStream must delegate to the PrintStream given as parameter, testable with reflection and CGLIB-proxy as target mock
			- note: can't override just selected methods, because the print's delegate to a private method, and anyways it would couple to PrintStream's implementation details
			- might break in future Java versions, if more methods are added to PrintStream, so beware of it
			! - or just use a CGLIB proxy (net.sf.cglib.proxy.MethodInterceptor which synchronizes and delegates to real PrintStream, except net.sf.cglib.proxy.NoOp for Object's methods)

- proper daemon shutdown
	- expose the Process instance from launcher, use it to write e2e-tests
	- send shutdown command from launcher after receiving the last suite event
	- exit after a timeout if no client connects to daemon or the client disconnects
	- remove the hack in fi.jumi.daemon.Main#exitWhenNotAnymoreInUse
	- print a message on daemon startup and shutdown; makes it easier to see from logs that when the JVM was restarted

- SuiteListener#onFailure cannot rely on the exception class from existing in the caller's class loader
	- introduce ExceptionSafetyGloves?
		- implementable as an exception with custom toString and that copies the StackTraceElements
		- provide getExceptionClassName: String
	- test: same toString as the original exception
	- test: same StackTraceElements
	- test: same toString & StackTraceElements also for cause
	- test: same output of printStackTrace

- end-to-end tests: failures outside tests (in drivers and core)
	OK - actor tests print dummy exceptions; solve by having a custom pluggable exception handler which doesn't print stack traces of a DummyException class
	OK - consider a command for stopping actors (Thread.interrupt(), DeathPill)
	- consider a supervisor pattern for actors (like in Akka)
	- maybe testable by throwing exceptions from a driver or by producing non-valid .class files

- deployment pipeline
	jumi:
		build
			build-release
		analyze
			coverage-report
	jumi-integration:
		test
			integration-test
	jumi-publish:
		publish [M]
			promote-staging
			smoke-test
			promote-central
			create-tags
			prepare-changelog
		announce [M]
			publish-changelog
			send-emails
	OK - install Go
	OK - configure CI build
	OK - generate unique version number for each build
		http://www.thoughtworks-studios.com/docs/go/current/help/dev_use_current_revision_in_build.html
		- pass GO_PIPELINE_COUNTER to update-to-release-version.rb
	OK - include Git revision in pom.properties
		http://stackoverflow.com/questions/10102818/custom-values-in-maven-pom-properties-file
		<archive> element: http://maven.apache.org/plugins/maven-jar-plugin/jar-mojo.html
		<pomPropertiesFile> element: http://maven.apache.org/shared/maven-archiver/index.html
			- does not work, see http://jira.codehaus.org/browse/MSHARED-154
		use a template directory, maybe in parent: http://stackoverflow.com/questions/2469922/generate-a-version-java-file-in-maven/7161303#7161303
			- in build tests check that the values are filtered, i.e. don't contain "$" or even better use a regexp of allowed values
		(1) create with buildnumber plugin: http://mojo.codehaus.org/buildnumber-maven-plugin/usage.html
		(2) or use ${env.GO_REVISION}
			http://www.thoughtworks-studios.com/docs/go/current/help/dev_use_current_revision_in_build.html
			- in build tests check that it's filtered when version is not snapshot (skip test when built locally, but run it in CI)
	- push-button releasing the staging repository
		OK - upload script: upload-to-maven-central.rb
		OK - activate sonatype-oss-release profile when building
			OK - scripts for all build steps, instead of keeping them in Go?
		OK - configure GPG signing
			https://docs.sonatype.org/display/Repository/Sonatype+OSS+Maven+Repository+Usage+Guide
			https://docs.sonatype.org/display/Repository/How+To+Generate+PGP+Signatures+With+Maven
			http://maven.apache.org/plugins/maven-gpg-plugin/
		OK - output of "set -x" goes to stderr and gets interleaved with stdout
		OK - check in the beginning of each .sh that all required env vars are present
			http://stackoverflow.com/questions/307503/whats-the-best-way-to-check-that-environment-variables-are-set-in-unix-shellscr
		OK - create GPG keys for Go, parameterize with GPG_KEYNAME
			http://maven.apache.org/plugins/maven-gpg-plugin/sign-mojo.html#keyname
			http://www.spywarewarrior.com/uiuc/gpg/gpg-com-0.htm
		OK - begin using the OSSRH repository
			OK - change the url in upload-to-maven-central.rb
			OK - create a production jumi-publish pipeline to Go
		- add commands for closing and promoting the OSSRH repository
			OK - close automatically
			- run smoke tests before promoting
			- promote automatically
			http://www.sonatype.com/books/nexus-book/reference/staging-sect-managing-plugin.html
			https://repository.sonatype.org/content/sites/maven-sites/nexus-maven-plugin/
	!! - publish the first release (after jumi-actors is in a good shape)
		OK - disable deployment of non-actor modules
			http://maven.apache.org/plugins/maven-deploy-plugin/deploy-mojo.html#skip
		!! - publish jumi-actors
		- enable deployment for all except end-to-end tests and the aggregate pom: jumi-api, jumi-core, jumi-daemon, jumi-launcher
	- activate sync to Maven Central
		https://docs.sonatype.org/display/Repository/Sonatype+OSS+Maven+Repository+Usage+Guide
		https://issues.sonatype.org/browse/OSSRH-3707
	- advertise the release
	- write a blog post: Continuous Delivery with Maven and Go into Maven Central

- misc refactoring
	- fix Maven's pomPropertiesFile element, get rid of the current workaround of a separate build.properties
		http://jira.codehaus.org/browse/MSHARED-154
		http://stackoverflow.com/questions/10102818/custom-values-in-maven-pom-properties-file
		<archive> element: http://maven.apache.org/plugins/maven-jar-plugin/jar-mojo.html
		<pomPropertiesFile> element: http://maven.apache.org/shared/maven-archiver/index.html
	- unit tests for fi.jumi.core.results
	- combine DuplicateOnTestFoundEventFilter and SuiteListenerAdapter, rename to SuiteEventNormalizer/RunEventNormalizer
	- logging actor messages could benefit from seeing that from which actor a messages was sent; a trace of intermediate actors
	- refactor SimpleUnit
		- simplity the tests by creating helper which runs using SuiteRunner, collects the results and provides assert methods
		- move to its own module, simpleunit
	- migrate Specsy to use Jumi (need the above test helper first)
	- packages by functionality
		core
			discovery
			drivers
			suite
			classes
			runs
	FAIL - try using FEST asserts in BuildTest, it should help with generics
	- BuildTest: try creating a non-generic assertThat method
	- kill daemon before removing temp files: fi.jumi.test.AppRunner#tearDown
	- SuiteRunner has a cyclic dependency with TestRunCoordinator
	- organize the project so that it's possible to run unit tests separate from end-to-end tests
		- put end-to-end tests in their own package, test.fi.jumi?
		- or use JUnit categories, maybe with a custom runner?
		- or use ClasspathSuite?
	- test execution might be best implemented using regular thread pools instead of actors
		- CPU bound threads should use an optimal number of threads per core
		- they take no input when running, so no actor handle needs to be created for them
		OK - the thing which coordinates a test class's workers might need to be an actor (it receives events from the tests), but it should also be able to exit itself when it has done its work
	- bullet proofing the public api, cross-references from javadocs to tests (a new xref tag?)
		- testId in onTestFinished must be correspond last onTestStarted, correctly nested
		- testId in onFailure must equal the currently running test
		- disallow TestNotifier.fireFailure and fireTestFinished after test is finished
		- log all incorrect usages to some internal log and make the suite fail?
		- TestClassListener: consider eliminating redundant parameters
	- evaluate JarJar or ProGuard, maybe it could minimize the jars better than the shade plugin by removing also unused methods
		http://sonatype.github.com/jarjar-maven-plugin/
		http://pyx4me.com/pyx4me-maven-plugins/proguard-maven-plugin/
	- seems that Eventizer.newBackend is not used; keep it for symmetry or remove it?
	- consider logging with http://code.google.com/p/minlog/

- improving TextUI
	OK - spacing between test runs (empty line or horizontal bar?)
	- option for showing all test runs or only failing
	(- if multiple readers are needed: Streamer class for receiving events from UI thread)
	- different colors for out (default), err (red), metadata e.g. test names (blue), binary output (yellow BG)?
		- JCons (uses JNI on Windows, so maybe support only Unix)
			http://jcons.sourceforge.net/
			http://sourceforge.net/projects/jcons/
		- could also JLine do it? (uses a native binary)
			http://jline.sourceforge.net/
			https://github.com/jline
		- misc links
			http://www.codeguru.com/forum/showthread.php?t=504096
			http://blogs.atlassian.com/2009/10/colour_your_console_ansicolor/
			http://en.wikipedia.org/wiki/ANSI_escape_code
			http://www.velocityreviews.com/forums/t143949-text-color-in-windows-console.html
			http://academic.evergreen.edu/projects/biophysics/technotes/program/ansi_esc.htm
			http://www.tldp.org/LDP/abs/html/colorizing.html
			http://stackoverflow.com/questions/7445658/how-to-detect-if-the-console-does-support-ansi-escape-codes-in-python
		- ANSI escape codes work in IDEA?
			http://youtrack.jetbrains.net/issue/IDEA-68679

- end-to-end tests: persistent daemon process
	- should drive better design on launcher side
	- connect to existing process
	- if daemon dies unexpectedly (System.exit/halt, JVM crash etc.), report it and restart next time
		http://vanillajava.blogspot.com/2011/12/test-complete-failure-of-jvm.html
	- make it reliable

- refactor jumi-actors-maven-plugin
	- DummyListenerToEvent: rename sender to target
	- EventToDummyListener: rename listener to target
	- switch to using Eclipse JDT DOM for code generation, create an internal DSL as necessary (factory methods to avoid setter hell)
		http://blog.cedarsoft.com/2010/08/code-generation-done-right/
		http://www.eclipse.org/jdt/core/index.php
		http://help.eclipse.org/indigo/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/core/dom/package-summary.html
		- walking skeleton
			1. take the old generator's output
			2. parse it to AST
				example: http://help.eclipse.org/indigo/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/core/dom/AST.html
				http://help.eclipse.org/indigo/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/core/dom/ASTParser.html
			3. convert AST to string
				example: http://help.eclipse.org/indigo/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/core/dom/AST.html
				http://help.eclipse.org/indigo/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/Document.html
				http://help.eclipse.org/indigo/topic/org.eclipse.platform.doc.isv/reference/api/org/eclipse/jface/text/IDocument.html#get()
			4. format using Eclipse Formatter
				http://help.eclipse.org/indigo/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/core/ToolFactory.html#createCodeFormatter
				http://help.eclipse.org/indigo/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/core/formatter/package-summary.html
				http://www.eclipse.org/jdt/core/codecoverage/B01/org.eclipse.jdt.core/org.eclipse.jdt.core.formatter/CodeFormatterApplication.java.html#L204
			5. use the Organize Imports operation, unless formatter already adds imports
				? http://help.eclipse.org/indigo/topic/org.eclipse.jdt.doc.isv/reference/api/org/eclipse/jdt/ui/actions/OrganizeImportsAction.html
				? http://plugins.intellij.net/plugin/?idea&id=6546
				http://stackoverflow.com/questions/2644440/simplifying-fully-qualified-names-in-eclipse
				- might need to transform the AST ourselves?
		- migrate to generating code with JDT AST
			- generate code with fully qualified names, rely on the formatter for imports
			- migrate to AST one method at a time, if possible
				- try using AST.newMethodDeclaration or AST.newBlock instead of AST.newCompilationUnit
			- delete the old code generator
	- @Generated annotation, example: @Generated(value = "fi.jumi.codegenerator.EventStubGenerator", comments = "Generated based on fi.jumi.codegenerator.DummyListener", date = "2000-01-01")
	- @Override annotation to all methods
	- annotation to suppress unchecked warnings due to type erasure?
	- toString?
	- hand-written serialization using bare DataOutput/DataInput? should give overall best performance without additional dependencies: https://github.com/eishay/jvm-serializers/wiki/
	- plugin pom: add-source with http://mojo.codehaus.org/build-helper-maven-plugin/
	- install plugin to local repository to avoid false alarms in jumi-core pom

- write performance tests
	- test: suite with a hundred test classes, each with a hundred tests, some of which also do printing; measure total time of running the suite
	- experiment with different queue implementations, for example ConcurrentLinkedQueue
	- try following the single writer principle: http://mechanical-sympathy.blogspot.com/2011/09/single-writer-principle.html
		- for example: separate queue for each test worker (implies parallelism = locally sequential, except for slow tests?, use a work stealing executor?) and one thread which loops through them and writes to the coordinator actor queue

- "Error creating shaded jar", probably an issue with NTFS's pending delete and the shade plugin
	- make a bug request, maybe also a patch
	http://mail-archives.apache.org/mod_mbox/maven-dev/200808.mbox/%3C835d522e0808281121g47eedd04u3c056998569be860@mail.gmail.com%3E

- investigate warnings on build:
	- happens when jumi-core-0.1.0-SNAPSHOT.jar (or daemon JAR) exists from the previous build
[WARNING] We have a duplicate net/orfjackal/jumi/core/INTERNAL/org/apache/commons/io/input/TailerListener.class in C:\DEVEL\Jumi\jumi\jumi-core\target\jumi-core-0.1.0-SNAPSHOT.jar
[WARNING] We have a duplicate net/orfjackal/jumi/core/INTERNAL/org/apache/commons/io/input/TailerListenerAdapter.class in C:\DEVEL\Jumi\jumi\jumi-core\target\jumi-core-0.1.0-SNAPSHOT.jar
[WARNING] We have a duplicate net/orfjackal/jumi/core/INTERNAL/org/apache/commons/io/input/TeeInputStream.class in C:\DEVEL\Jumi\jumi\jumi-core\target\jumi-core-0.1.0-SNAPSHOT.jar
[WARNING] We have a duplicate net/orfjackal/jumi/core/INTERNAL/org/apache/commons/io/input/XmlStreamReader.class in C:\DEVEL\Jumi\jumi\jumi-core\target\jumi-core-0.1.0-SNAPSHOT.jar

- Pronouncing Jumi: ['jumi]
	http://en.wikipedia.org/wiki/International_Phonetic_Alphabet
