
TODO NEXT:
- end-to-end tests: failing tests
	OK - write a test
	OK - make it pass
		OK - TestClassRunnerTest: test class with one failing test
		OK - refactor TestClassRunnerTest
			OK - tests for SpyTestClassRunnerListener
			OK - use it in all tests, remove mocks
			OK - make it generic, using dynamic proxies
			OK - refactor tests to not use a domain interface
		OK - see what fails next
			OK - executor is null (write a test in TestClassRunnerTest)
			OK - daemon is not sending events about failures
				OK - implement fi.jumi.test.simpleunit.SimpleUnit.RunTestMethod#run
			OK - SuiteStateCollector does not implement onTestStarted, onTestFinished, onFailure
	- make it right
		- duplicate method signatures in TestClassListener and TestClassRunnerListener
- misc refactoring
	- when an event interface contains many methods, there are no spaces between methods in SuiteListenerToEvent
	- test execution might be best implemented using regular thread pools instead of actors
		- CPU bound threads should use an optimal number of threads per core
		- they take no input when running, so no actor handle needs to be created for them
		OK - the thing which coordinates a test class's workers might need to be an actor (it receives events from the tests), but it should also be able to exit itself when it has done its work
	- bullet proofing the public api, cross-references from javadocs to tests (a new xref tag?)
	- refactor EventStubGenerator:
		- toString methods for generated events would make debugging easier
		- get generic method parameter types using java.lang.reflect.Method#getGenericParameterTypes, use it to also replace the current generics printing (ParameterizedType can be created from a dummy field)
			- for example listener method with a List<String> parameter
		- extract domain object for imports
		- extract domain objects for classes and methods, then gather imports using the visitor pattern?
	- put end-to-end tests in their own package (test.fi.jumi?), separate them from unit tests
		- or use JUnit categories, maybe with a custom runner?
- end-to-end tests: reporting exception stack traces
- end-to-end tests: failures outside tests (in drivers and core)
	- actor tests print dummy exceptions; solve by having a custom pluggable exception handler which doesn't print stack traces of a DummyException class
- end-to-end tests: reporting test output
- end-to-end tests: multiple tests
	- identify concurrent test runs with a unique ID
	- run on more than one thread; performance must improve (write a performance test with sleeps?)
- end-to-end tests: persistent daemon process
	- should drive better design on launcher side
	- connect to existing process
	- if daemon dies unexpectedly (System.exit/halt, JVM crash etc.), report it and restart next time
	- make it reliable
- refactor jumi-actors-maven-plugin
	- DummyListenerToEvent: rename sender to target
	- EventToDummyListener: rename listener to target
	- @Generated annotation
	- annotation to suppress unchecked warnings due to type erasure?
	- toString?
	- Externalizable? should give overall best performance without additional dependencies: https://github.com/eishay/jvm-serializers/wiki/
	- plugin pom: add-source with http://mojo.codehaus.org/build-helper-maven-plugin/
	- install plugin to local repository to avoid false alarms in jumi-core pom

- organize the project so that it's possible to run unit tests separate from end-to-end tests
	- maybe using ClasspathSuite?

- "Error creating shaded jar", probably an issue with NTFS's pending delete and the shade plugin
	- make a bug request, maybe also a patch
	http://mail-archives.apache.org/mod_mbox/maven-dev/200808.mbox/%3C835d522e0808281121g47eedd04u3c056998569be860@mail.gmail.com%3E

- investigate warnings on build:
	- happens when jumi-core-0.1.0-SNAPSHOT.jar (or daemon JAR) exits from the previous build
[WARNING] We have a duplicate net/orfjackal/jumi/core/INTERNAL/org/apache/commons/io/input/TailerListener.class in C:\DEVEL\Jumi\jumi\jumi-core\target\jumi-core-0.1.0-SNAPSHOT.jar
[WARNING] We have a duplicate net/orfjackal/jumi/core/INTERNAL/org/apache/commons/io/input/TailerListenerAdapter.class in C:\DEVEL\Jumi\jumi\jumi-core\target\jumi-core-0.1.0-SNAPSHOT.jar
[WARNING] We have a duplicate net/orfjackal/jumi/core/INTERNAL/org/apache/commons/io/input/TeeInputStream.class in C:\DEVEL\Jumi\jumi\jumi-core\target\jumi-core-0.1.0-SNAPSHOT.jar
[WARNING] We have a duplicate net/orfjackal/jumi/core/INTERNAL/org/apache/commons/io/input/XmlStreamReader.class in C:\DEVEL\Jumi\jumi\jumi-core\target\jumi-core-0.1.0-SNAPSHOT.jar

- Pronouncing Jumi: ['jumi]
	http://en.wikipedia.org/wiki/International_Phonetic_Alphabet

ROADMAP:
- Initial relase, technology preview
	- Runs tests on many cores
	- Custom JVM options
	- Caches library JARs
	- Make sure that test code cannot access the classes used by Jumi, except Jumi API; avoid library version conflicts using custom class loaders
	- Minimal console UI, shows only failing tests, configured using Java code
	- Debug tray GUI, shows only individual test runs (list of run IDs on left, run log on right; maybe also the test names in a tree, leftmost; print all test run data in log, but no colors or styles)
	- New runner for Specsy (Specsy 2: rewrite in Java, support more languages)
	- Publish a video demonstrating the speed. Use Dimdwarf as a sample project. Compare test run times:
		- Maven (only the test stage of the build)
		- IDEA
		- Eclipse
		- NetBeans
		- sbt (about same speed as Jumi?)
		- Jumi (1-thread, cold-start)
		- Jumi (1-thread, warm-start)
		- Jumi (4-thread, cold-start)
		- Jumi (4-thread, warm-start)

- Jumi Cluster, initial release
	- Runs tests on many machines (detects changed files and uploads them)
	- Simplest possible class-level distribution (round-robin over all machines, double-run test classes on local machine if the local machine runs out of work before the remote machines return their results)
	- Configuration using text files, no UI
	- Minimal single-user authentication (using Apache Shiro), no encryption
	- Release first with free evaluation licences, then build proper checkout systems and license checks

- Integration test project
	- Infrastructure for running tests against specified Jumi version
	- Tests for Jumi Cluster
	- Document and advertise it to framework developers

- Gather feedback and figure out what to build next (a proper UI perhaps; delay interaction design until here)

- Planned CORE features:
	- Build tool and IDE integration (Maven has the highest priority)
	- Well designed UI
	- Statistics (required by many other features)
	- Test priorization, run first those which will most probably fail, run fast tests first etc.
	- Per-module working directory (requires a separate JVM for each module)
	- IO/CPU boundness checking
	- Work around the issue of class loader locking the JARs (it's possible, though rare, that some JAR dependencies are generated by the same build)
	- Embed classmembersorter as a utility, in case framework developers would like to use it?
	- Faking "java.class.path", so that code which relies on it would not be disturbed by the use of multiple classloaders (should be optional and off by default?)

- Planned CLUSTER features:
	- Combine privileges from multiple licenses, limit concurrent users
	- Make buying a license easy, make sells scalable (fully automated)
	- Configuration UI (requires a plugin API)
	- Cloud provider integration (Amazon, others)
	- Provide startup scripts for the cluster daemon (Linux, Windows)
	- Location optimization: run fast tests locally
	- Distribute tests evenly over servers, based on expected duration
	- Test-level distribution (execute one test class over multiple servers)
	- Multi-environment test execution (e.g. run all tests on both Windows and Linux, or different JVM versions)
	- Multi-user authentication (per-user keys)
	- Encrypted communication over network (optional; takes CPU power)
