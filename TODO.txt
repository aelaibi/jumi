
TODO NEXT:
- clean build fails: core's shaded artifact does not include core
- intellij annotations must be found from a maven repository (or system scope?)
- hide the maven warning about 'parent.relativePath'
- end-to-end tests: run tests (simplest possible - zero tests?)
- public api (create "SampleUnit")

[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:2.3.2:compile (default-compile) on project jumi-daemon: Compilation failure: Compilation failure:
[ERROR] \DEVEL\Jumi\jumi\jumi-daemon\src\main\java\net\orfjackal\jumi\daemon\Main.java:[7,30] package net.orfjackal.jumi.core does not exist
[ERROR] \DEVEL\Jumi\jumi\jumi-daemon\src\main\java\net\orfjackal\jumi\daemon\Main.java:[11,27] cannot find symbol
[ERROR] symbol  : variable Hello
[ERROR] location: class net.orfjackal.jumi.daemon.Main



- Pronouncing Jumi: ['jumi]
	http://en.wikipedia.org/wiki/International_Phonetic_Alphabet

ROADMAP:
- Initial relase, technology preview
	- Runs tests on many cores
	- Custom JVM options
	- Caches library JARs
	- Make sure that test code cannot access the classes used by Jumi, except Jumi API; avoid library version conflicts using custom class loaders
	- Minimal console UI, shows only failing tests, configured using Java code
	- Debug tray GUI, shows only individual test runs (list of run IDs on left, run log on right; maybe also the test names in a tree, leftmost; print all test run data in log, but no colors or styles)
	- New runner for Specsy (Specsy 2: rewrite in Java, support more languages)
	- Publish a video demonstrating the speed. Use Dimdwarf as a sample project. Compare test run times:
		- Maven (only the test stage of the build)
		- IDEA
		- Eclipse
		- NetBeans
		- sbt (about same speed as Jumi?)
		- Jumi (1-thread, cold-start)
		- Jumi (1-thread, warm-start)
		- Jumi (4-thread, cold-start)
		- Jumi (4-thread, warm-start)

- Jumi Cluster, initial release
	- Runs tests on many machines (detects changed files and uploads them)
	- Simplest possible class-level distribution (round-robin over all machines, double-run test classes on local machine if the local machine runs out of work before the remote machines return their results)
	- Configuration using text files, no UI
	- Minimal single-user authentication (using Apache Shiro), no encryption
	- Release first with free evaluation licences, then build proper checkout systems and license checks

- Integration test project
	- Infrastructure for running tests against specified Jumi version
	- Tests for Jumi Cluster
	- Document and advertise it to framework developers

- Gather feedback and figure out what to build next (a proper UI perhaps; delay interaction design until here)

- Planned CORE features:
	- Build tool and IDE integration (Maven has the highest priority)
	- Well designed UI
	- Statistics (required by many other features)
	- Test priorization, run first those which will most probably fail, run fast tests first etc.
	- Per-module working directory (requires a separate JVM for each module)
	- IO/CPU boundness checking
	- Work around the issue of class loader locking the JARs (it's possible, though rare, that some JAR dependencies are generated by the same build)
	- Embed classmembersorter as a utility, in case framework developers would like to use it?

- Planned CLUSTER features:
	- Combine privileges from multiple licenses, limit concurrent users
	- Make buying a license easy, make sells scalable (fully automated)
	- Configuration UI (requires a plugin API)
	- Cloud provider integration (Amazon, others)
	- Provide startup scripts for the cluster daemon (Linux, Windows)
	- Location optimization: run fast tests locally
	- Distribute tests evenly over servers, based on expected duration
	- Test-level distribution (execute one test class over multiple servers)
	- Multi-environment test execution (e.g. run all tests on both Windows and Linux, or different JVM versions)
	- Multi-user authentication (per-user keys)
	- Encrypted communication over network (optional; takes CPU power)
