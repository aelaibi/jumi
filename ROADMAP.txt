
ROADMAP:
- JUnit backward compatibility

- Integration test project
	- Infrastructure for running tests against specified Jumi version
	- Tests for Specsy
	- Document and advertise it to framework developers

- Maven integration
	- Run tests as part of a Maven build
	- Produce test reports in same format as Surefire
	- Generate bootsrap classes for running tests within an IDE with the same settings as Maven

- Beta release(s)
	- Before & after suite events (probably as methods on a runner; somebody can even make a runner which doesn't run tests, but only those hooks, in case a testing framework doesn't itself support them)
	- Caches library JARs (implies a reused daemon process)
	- Make sure that test code cannot access the classes used by Jumi, except Jumi API; avoid library version conflicts using custom class loaders
	- Debug tray GUI, shows only individual test runs (list of run IDs on left, run log on right; maybe also the test names in a tree, leftmost; print all test run data in log, but no colors or styles)
	- Publish a video demonstrating the speed. Use Dimdwarf as a sample project. Compare test run times:
		- Maven (only the test stage of the build)
		- IDEA
		- Eclipse
		- NetBeans
		- sbt (find out whether sbt does class loader caching also for tests and not just the compiler)
		- Jumi (1-thread, cold-start)
		- Jumi (1-thread, warm-start)
		- Jumi (4-thread, cold-start)
		- Jumi (4-thread, warm-start)

- Gather feedback and figure out what to build next (a proper UI perhaps; delay interaction design until here)

- Planned features:
	- Build tool, IDE and CI integration (Maven has the highest priority)
	- Well designed UI
	[release 1.0 around here?]
	- Ignored/filtered tests
		- Suggestion: Provide SuiteNotifier.isIgnored(TestId id, String name) that drivers may query, to get common input from IDEs. Either parameter may be null, if it's not uniquely identifying for that framework (e.g. TestId based on order of methods, or allows duplicate test names)
		- Also a notification mechanism SuiteNotifier.fireTestIgnored(TestId) to show in results what the drivers ultimately decided to ignore
	- Pending tests
		- Must support marking a test pending both before and after starting to execute it (e.g. @Ignore vs. assumeThat())
		- Should the pending status be per suite, or per run? (i.e. when a test is run multiple times, can some of them be pending and not others?)
	- Test groups/tags for choosing which tests to execute. Probably string based (http://tech.groups.yahoo.com/group/junit/message/24017) or hybrid (http://tech.groups.yahoo.com/group/junit/message/24024)
	- Statistics (required by many other features)
	- Test priorization, run first those which will most probably fail, run fast tests first etc.
	- Look for the fastest order of running tests from class loading point of view (best-effort thread affinity at test class level, to avoid all threads being blocked by loading the same classes?)
	- Detect what classes a test depends on (e.g. by spying on the class loader) and run only those (or those first)
	- Per-module working directory (requires a separate JVM for each module)
	- Common abstraction for skipping tests? Or is skipping tests too framework specific to be abstracted properly?
	- IO/CPU boundness checking
	- Work around the issue of class loader locking the JARs (it's possible, though rare, that some JAR dependencies are generated by the same build)
	- Embed classmembersorter as a utility, in case framework developers would like to use it?
	- Faking "java.class.path", so that code which relies on it would not be disturbed by the use of multiple classloaders (should be optional and off by default?)
	- Integration with PIT mutation testing (http://pitest.org/), preferably as an optional plugin to drive the plugin API
